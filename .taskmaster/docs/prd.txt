<context>
# Overview  
This system is a local-first data replication and sync system designed for web browsers and server environments. It enables real-time data synchronization across clients with instant local operations and offline capabilities. The system leverages a triple store architecture and Hybrid Logical Clocks (HLC) for fine-grained conflict resolution and schema evolution.

# Core Features  
- **Local-First Operations**: All reads and writes occur locally on the client for instant responsiveness and offline capability. Changes are then replicated globally.
- **Real-time Synchronization**: Uses WebSocket and HTTP for efficient, real-time data replication and live collaboration features via Rooms.
- **Client API**: A fully typed API for interacting with the database, supporting CRUD, bulk operations, advanced queries (filtering, ordering, limiting, relations, aggregations), reactive subscriptions, and pagination.
- **Schema Definition & Validation**: Client-only schema definition using a `createSchema` utility, ensuring type safety and enabling schema evolution through field-level storage and fallbacks.
- **Conflict Resolution (HLC)**: Field-level Hybrid Logical Clocks (HLC) ensure automatic merging of concurrent updates to different fields and last-write-wins for same-field conflicts.
- **Real-time Rooms**: Provides ephemeral pub/sub capabilities for events, per-user session status, and room-wide shared status, ideal for presence, cursors, and collaboration.

# User Experience  
- **Instant Responsiveness**: Users experience immediate feedback on all actions due to local-first operations, eliminating loading states for user interactions.
- **Offline Capability**: The application remains fully functional even without network connectivity, with changes syncing once online.
- **Seamless Collaboration**: Real-time Rooms facilitate fluid multi-user experiences like collaborative document editing with live cursors, typing indicators, and event broadcasting.
- **Predictable Data Interaction**: The strongly-typed Client API ensures developers have a clear and predictable way to interact with data, reducing bugs and improving development speed.
- **Eventual Consistency**: While operations are instant locally, the system ensures global data coherence through background synchronization, providing a robust and reliable user experience.
</context>
<PRD>
# Technical Architecture  
- **System Components**:
    - **Client**: Application Layer (React/Svelte Integration, Client API), Sync Engine (Local-first Operations, HLC Conflict Resolution, Replication Protocol, Connection Management), Triple Store (Query Engine, Schema Validation, Change Tracking), Persistence Layer (IndexedDB Adapter - deferred).
    - **Server**: API Layer (Authentication & Authorization, Tenant Resolution, Sync Protocol Handler), Sync Engine (Multi-tenant Coordination, HLC Conflict Resolution, Change Broadcasting, Connection Management), Triple Store (Query Engine, Schema Validation - schema-agnostic, Change Tracking), Persistence Layer (Per-tenant SQLite/Turso).
- **Data Models**: Data is stored in a Triple Store format (`subject`, `predicate`, `object`) with field-level HLC timestamps. Document IDs are client-generated Nano IDs. Entity fields are mapped to strings, numbers, booleans, dates, and references (t.ref, t.refMany).
- **APIs and Integrations**: The system exposes a TypeScript-enforced client API for data interaction. Communication between client and server is via WebSocket for real-time updates and HTTP for bulk operations and initial data loading.
- **Infrastructure Requirements**: Server requires SQLite for persistence (Turso recommended for distributed sync). Real-time Rooms are in-memory on the server, ensuring ephemeral state for collaboration features.

# Development Roadmap  
- **MVP Requirements**:
    - Implement core `createSchema` and client initialization.
    - Develop basic CRUD operations (create, update, replace, delete) for single documents.
    - Implement fundamental query capabilities: `query`, `queryOne` with `fields`, `where`, `orderBy`, and `limit` operators.
    - Establish real-time subscriptions for queries (`subscribe`, `subscribeOne`).
    - Develop basic Real-time Room functionality: `join`, `emit` events, `setUserStatus`, `on` event listeners, `onUserStatus`, `onRoomStatus`.
    - Implement basic HLC generation and field-level last-write-wins conflict resolution for local operations and initial sync.
    - Client-side in-memory triple store with basic indexing.
- **Future Enhancements**:
    - **Persistence Layer**: Integrate IndexedDB for client-side persistence.
    - **Advanced Query Features**: Implement aggregations (`sum`, `avg`, `count`, `min`, `max`) and `groupBy` clauses.
    - **Pagination**: Implement `.paginated()` and `.preloadPaginated()` for efficient handling of large datasets.
    - **Preloading**: Extend `preload` and `preloadOne` for server-side data fetching to eliminate loading states in UI frameworks.
    - **Batch Operations**: Implement `client.database.batch.execute()` for non-atomic bulk write operations.
    - **Authentication & Authorization**: Implement client authentication (JWT), row-level security, and a management dashboard for App ID generation.
    - **Network Resilience**: Enhance connection recovery, partition handling, and automatic reconnection with timestamp-based gap recovery.
    - **Storage Optimization**: Implement strategies for data pruning, compaction, and advanced caching.
    - **Framework Integrations**: Provide official hooks/wrappers for other popular frameworks beyond React and Svelte.

# Logical Dependency Chain
- **Foundation (Core Sync Engine)**:
    1. Define core triple store structure and HLC mechanism.
    2. Implement client-side `createSchema` and basic entity type definitions.
    3. Develop low-level client-side CRUD operations on the in-memory triple store.
    4. Implement client-side query engine for basic filtering and field selection.
    5. Establish WebSocket and HTTP connection management for replication.
- **Core Client API & Real-time Features**:
    1. Build out the public Client API wrappers for CRUD and basic queries (`query`, `queryOne`).
    2. Integrate reactive subscriptions (`subscribe`, `subscribeOne`) on the client.
    3. Implement Real-time Rooms basic functionality (join, emit, setUserStatus, listeners).
- **Data Handling Enhancements**:
    1. Implement bulk operations (`updateMany`, `replaceMany`, `deleteMany`).
    2. Develop pagination (`paginated`, `preloadPaginated`) for efficient data display.
    3. Implement preloading (`preload`, `preloadOne`) for server-side rendering/initial data.
    4. Add advanced query features like aggregations and `groupBy`.
- **Scalability & Robustness**:
    1. Integrate client-side IndexedDB persistence.
    2. Enhance network resilience (connection recovery, partition handling).
    3. Implement robust authentication and authorization mechanisms.

# Risks and Mitigations  
- **Technical Challenges**:
    - **HLC Implementation Complexity**: Ensuring correct HLC generation, comparison, and conflict resolution at the field level across distributed clients is complex. *Mitigation: Start with a simplified in-memory HLC implementation and rigorously test with simulated concurrent scenarios.*
    - **Query Engine Performance**: Datalog-style queries can be computationally intensive on large datasets. *Mitigation: Implement efficient indexing strategies on the triple store (subject, predicate, object) and prioritize query optimization during development.*
    - **Schema Evolution**: Managing schema changes without breaking old clients. *Mitigation: The field-level storage and fallback mechanisms in the schema design inherently provide strong backward and forward compatibility.*
- **Figuring out the MVP that we can build upon**:
    - The system is inherently complex with many moving parts. Identifying the absolute minimum viable product that demonstrates core value and is extensible is crucial. *Mitigation: Focus MVP on local-first CRUD, basic querying, and real-time rooms for a single entity type, deferring advanced features and server-side persistence optimization.*
- **Resource Constraints**:
    - Development of a full-stack local-first sync system is resource-intensive. *Mitigation: Prioritize core features, leverage TypeScript for shared code, and defer complex infrastructure like a management dashboard.*

# Appendix  
- **Research Findings**: Refer to `client-api.md` for detailed client API examples and `design.md` for comprehensive system design principles, including triple store architecture, HLC, schema-agnostic server, and synchronization protocols.
- **Technical Specifications**: The `createSchema` utility defines entities and rooms with specific field types (`t.string`, `t.number`, `t.boolean`, `t.date`, `t.ref`, `t.refMany`). The `DatabaseResult` type is used for consistent API responses. Error handling prioritizes data integrity, treating invalid data as undefined and gracefully handling type coercions.))
