# Task ID: 3
# Title: Develop Low-level Client-side In-memory CRUD Operations
# Status: in-progress
# Dependencies: 1, 2
# Priority: high
# Description: Implement the core create, read, update, and delete operations directly on the client's in-memory triple store, incorporating HLC for local conflict resolution.
# Details:
This involves the internal logic for manipulating triples, generating HLC timestamps for new or updated fields, and applying last-write-wins conflict resolution for same-field concurrent updates locally. Operations should be instant and provide immediate feedback.

# Test Strategy:
Unit tests for each CRUD operation (create, update, delete, read). Concurrency tests to simulate local concurrent writes to the same field and verify HLC-based last-write-wins behavior. Performance tests for basic operations on a small dataset.

# Subtasks:
## 1. Initialize Client Factory & In-memory Triple Store [done]
### Dependencies: None
### Description: Set up the client factory, initialize the in-memory triple store, and integrate the HLC mechanism for timestamp generation and local conflict resolution. This forms the foundational layer for all subsequent CRUD operations.
### Details:
Implement the `createClient` factory function. Establish the internal data structure for the in-memory triple store (e.g., `Map<subject, Map<predicate, {value, hlc_timestamp}>>`). Integrate the HLC utility (from Task 1) for generating timestamps for new/updated triples. Define the last-write-wins conflict resolution logic for same-field concurrent updates.
<info added on 2025-08-29T03:25:31.257Z>
The `create` operation will be exposed via the dynamic `database` API, which is generated using a Proxy based on the provided schema. This API will be the entry point for creating new entities, ensuring schema validation and applying fallback logic as defined.
</info added on 2025-08-29T03:25:31.257Z>

## 2. Implement `create` Operation with Schema Validation & Fallbacks [done]
### Dependencies: 3.1
### Description: Develop the `create` method for adding new entities to the in-memory store, ensuring schema validation and applying fallback values as defined in the schema.
### Details:
Implement the `client.create()` method. Integrate with the schema definition utility (from Task 2) to validate incoming data against the defined schema. Apply fallback values for missing fields as per schema. Generate HLC timestamps for all new triples using the integrated HLC utility.
<info added on 2025-08-29T03:32:27.880Z>
The `create` operation will be exposed via `client.database.<entityName>.create(fields)`. Validation must specifically enforce that all required fields are present. For each field in the final entity, a triple of the form `(<new_entity_id>`, `<entityName>/<fieldName>`, `<value>)` must be generated and stored. The operation should return the complete created entity, including auto-generated fields like `id`, `createdAt`, and `updatedAt`.
</info added on 2025-08-29T03:32:27.880Z>

## 3. Implement `read` Operation for Entity Retrieval [done]
### Dependencies: 3.1
### Description: Develop the `read` method to efficiently retrieve entities or specific fields from the client's in-memory triple store.
### Details:
Implement `client.read()` to fetch entities by ID or query for specific fields. Ensure efficient retrieval from the in-memory store. Consider supporting basic filtering or projection if implied by `client-api.md`.
<info added on 2025-08-29T03:32:34.558Z>
The `read` functionality will be exposed through `query` and `queryOne` methods on the entity-specific API (e.g., `client.database.users.query(...)`). This will involve implementing a Datalog-style query engine that operates on the in-memory triple store as described in `design.md`. The query engine must support filtering (`where`), field selection (`fields`), sorting (`orderBy`), and limiting results (`limit`). The implementation should gather all triples for matching subjects and reconstruct entity objects based on the `fields` selection.
</info added on 2025-08-29T03:32:34.558Z>

## 4. Implement `update` & `replace` Operations with Functional Updates [done]
### Dependencies: 3.1, 3.3
### Description: Develop the `update` and `replace` methods to modify existing entities, supporting functional updates and applying HLC-based last-write-wins conflict resolution.
### Details:
Implement `client.update()` and `client.replace()`. Support passing functions to update fields (e.g., `count: c => c + 1`). Generate new HLC timestamps for updated fields using the integrated HLC utility. Apply last-write-wins logic based on HLC timestamps for concurrent updates to the same field.
<info added on 2025-08-29T03:32:39.323Z>
The methods should be accessed via `client.database.<entityName>.update({ id, fields })` and `client.database.<entityName>.replace({ id, fields })`. For `update`, only provided fields are modified. For `replace`, all required fields must be provided, and unspecified optional fields are cleared. Both methods must support a functional `fields` argument of the form `(prev) => ({...})` for atomic updates. The last-write-wins conflict resolution strategy must be applied at the field level as specified in `design.md`.
</info added on 2025-08-29T03:32:39.323Z>

## 5. Implement `delete` Operation for Entities/Fields [done]
### Dependencies: 3.1
### Description: Develop the `delete` method to remove entities or specific fields from the in-memory triple store.
### Details:
Implement `client.delete()` to remove entire entities by ID or specific predicates for an entity. Ensure immediate removal from the in-memory store.
<info added on 2025-08-29T03:32:44.328Z>
For `client.database.<entityName>.delete(id)`, instead of immediate removal, a 'tombstone' triple `(<entityId>, "_deleted", true)` with an HLC timestamp must be created. The query engine must be updated to filter out entities with this tombstone, ensuring deletions are replicated and win over concurrent updates.
</info added on 2025-08-29T03:32:44.328Z>

## 6. Implement Bulk `updateMany` & `replaceMany` Operations [deferred]
### Dependencies: 3.4, 21
### Description: Develop bulk `updateMany` and `replaceMany` methods for efficient modification of multiple entities, leveraging the single update/replace logic.
### Details:
Implement `client.updateMany()` and `client.replaceMany()`. These methods should iterate over the provided entities/updates and call the respective single `update` or `replace` logic internally, ensuring HLC and conflict resolution are applied per entity/field. Optimize for batch processing where possible.
<info added on 2025-08-29T03:32:48.983Z>
Implement `client.database.<entityName>.updateMany({ where, fields })` and `client.database.<entityName>.replaceMany({ where, fields })`. These methods should first query the triple store to find all entities matching the `where` clause. For each matching entity, they should then apply the logic from the single `update` or `replace` operation internally, ensuring HLC and conflict resolution are applied per entity/field. Both `updateMany` and `replaceMany` should support functional `fields` arguments. The operations should be performed as a batch, and the return value should indicate the count of affected documents, as shown in `client-api.md`.
</info added on 2025-08-29T03:32:48.983Z>

## 7. Implement Bulk `deleteMany` Operation [deferred]
### Dependencies: 3.5, 21
### Description: Develop the bulk `deleteMany` method for efficient removal of multiple entities or fields from the in-memory store.
### Details:
Implement `client.deleteMany()`. This method should iterate over the provided entity IDs/field paths and call the single `delete` logic internally. Optimize for batch processing.
<info added on 2025-08-29T03:32:58.082Z>
The method signature will be `client.database.<entityName>.deleteMany({ where })`. It will identify entities by querying the triple store using the `where` clause. Deletion will involve creating a 'tombstone' triple for each identified entity, consistent with the single `delete` operation. The method should return the total count of documents marked for deletion.
</info added on 2025-08-29T03:32:58.082Z>

## 8. Comprehensive CRUD Testing & Performance Benchmarking [pending]
### Dependencies: 3.2, 3.3, 3.4, 3.5, 3.6, 3.7
### Description: Conduct comprehensive unit, integration, and performance tests for all implemented in-memory CRUD operations, including HLC-based conflict resolution.
### Details:
Write extensive unit tests covering edge cases for each CRUD method. Develop integration tests to verify end-to-end data flow and consistency across multiple operations. Implement concurrency tests to simulate local concurrent writes to the same field and verify HLC-based last-write-wins behavior. Conduct performance benchmarks for basic operations on varying dataset sizes to ensure 'instant' feedback.
<info added on 2025-08-29T03:33:06.169Z>
The test suite will be expanded to explicitly cover all CRUD operations (`create`, `query`, `update`, `replace`, `delete`, and their `many` variants). Tests will verify: correct triple manipulation in the in-memory store; schema validation and fallback application; functional updates executing correctly; HLC timestamp generation and last-write-wins conflict resolution for concurrent local updates; correct handling of delete tombstones in queries; and bulk operations affecting the correct set of documents. Performance benchmarks will specifically cover each CRUD operation on a reasonably sized in-memory dataset to ensure 'instant' feedback.
</info added on 2025-08-29T03:33:06.169Z>

## 9. Create and Use Custom `DatabaseError` Type [pending]
### Dependencies: None
### Description: Define a custom `DatabaseError` class and update all error-throwing paths in the client to use this type instead of the generic `Error` class, as specified in the documentation.
### Details:


## 10. Standardize CRUD Return Types to `DatabaseResult` [pending]
### Dependencies: None
### Description: Refactor `update`, `replace`, and `delete` methods to return the `DatabaseResult<void>` type as specified in the client API documentation, instead of the current `Promise<{ error?: Error }>`. The `DatabaseResult` should not be a promise itself.
### Details:


## 11. Implement Functional Updates for `update` and `replace` [pending]
### Dependencies: None
### Description: Add support for functional updates to the `update` and `replace` methods, allowing a function `(prev) => ({...})` to be passed as the `fields` argument for atomic operations.
### Details:


